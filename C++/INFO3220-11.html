<!DOCTYPE html>
<!-- saved from url=(0068)http://sydney.edu.au/engineering/it/courses/info3220/tutorial11.html -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" class="gr__sydney_edu_au"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>INFO3220</title>
		
		<link rel="stylesheet" type="text/css" href="./INFO3220-12_files/bootstrap.css">
		<link rel="stylesheet" type="text/css" href="./INFO3220-12_files/base.css" media="screen">
		<link rel="stylesheet" type="text/css" href="./INFO3220-12_files/baseForPrinting.css" media="print">
		<script type="text/javascript" src="./INFO3220-12_files/jquery-1.10.1.min.js.download"></script><style type="text/css">
:root #content > #right > .dose > .dosesingle,
:root #content > #center > .dose > .dosesingle,
:root .addthis_toolbox,
:root #header + #content > #left > #rlblock_left
{ display: none !important; }</style>
		<script type="text/javascript" src="./INFO3220-12_files/tutorial11.js.download"></script>
	</head><script>function inject(){function a(){function a(a){parent.postMessage({type:"blockedWindow",args:JSON.stringify(a)},l)}function b(a){var b=a[1];return null!=b&&["_blank","_parent","_self","_top"].indexOf(b)<0?b:null}function e(a,b){var c;for(c in a)try{void 0===b[c]&&(b[c]=a[c])}catch(d){}return b}var g=arguments,h=!0,j=null,k=null;if(null!=window.event&&(k=window.event.currentTarget),null==k){for(var m=g.callee;null!=m.arguments&&null!=m.arguments.callee.caller;)m=m.arguments.callee.caller;null!=m.arguments&&m.arguments.length>0&&null!=m.arguments[0].currentTarget&&(k=m.arguments[0].currentTarget)}null!=k&&(k instanceof Window||k===document||null!=k.URL&&null!=k.body||null!=k.nodeName&&("body"==k.nodeName.toLowerCase()||"#document"==k.nodeName.toLowerCase()))?(window.pbreason="Blocked a new window opened with URL: "+g[0]+" because it was triggered by the "+k.nodeName+" element",h=!1):h=!0;document.webkitFullscreenElement||document.mozFullscreenElement||document.fullscreenElement;if(((new Date).getTime()-d<1e3||isNaN(d)&&c())&&(window.pbreason="Blocked a new window opened with URL: "+g[0]+" because a full screen was just initiated while opening this url.",document.exitFullscreen?document.exitFullscreen():document.mozCancelFullScreen?document.mozCancelFullScreen():document.webkitCancelFullScreen&&document.webkitCancelFullScreen(),h=!1),1==h){j=f.apply(this,g);var n=b(g);if(null!=n&&(i[n]=j),j!==window){var o=(new Date).getTime(),p=j.blur;j.blur=function(){(new Date).getTime()-o<1e3?(window.pbreason="Blocked a new window opened with URL: "+g[0]+" because a it was blured",j.close(),a(g)):p()}}}else{var q={href:g[0]};q.replace=function(a){q.href=a},j={close:function(){return!0},test:function(){return!0},blur:function(){return!0},focus:function(){return!0},showModelessDialog:function(){return!0},showModalDialog:function(){return!0},prompt:function(){return!0},confirm:function(){return!0},alert:function(){return!0},moveTo:function(){return!0},moveBy:function(){return!0},resizeTo:function(){return!0},resizeBy:function(){return!0},scrollBy:function(){return!0},scrollTo:function(){return!0},getSelection:function(){return!0},onunload:function(){return!0},print:function(){return!0},open:function(){return this},opener:window,closed:!1,innerHeight:480,innerWidth:640,name:g[1],location:q,document:{location:q}},e(window,j),j.window=j;var n=b(g);if(null!=n)try{i[n].close()}catch(r){}setTimeout(function(){var b;b=j.location instanceof Object?j.document.location instanceof Object?null!=q.href?q.href:g[0]:j.document.location:j.location,g[0]=b,a(g)},100)}return j}function b(a){d=a?(new Date).getTime():0/0}function c(){return document.fullScreenElement&&null!==document.fullScreenElement||null!=document.mozFullscreenElement||null!=document.webkitFullscreenElement}var d,e="originalOpenFunction",f=window.open,g=document.createElement,h=document.createEvent,i={},j=0,k=null,l=window.location!=window.parent.location?document.referrer:document.location;window[e]=window.open,window.open=function(){try{return a.apply(this,arguments)}catch(b){return null}},document.createElement=function(){var a=g.apply(document,arguments);if("a"==arguments[0]||"A"==arguments[0]){j=(new Date).getTime();var b=a.dispatchEvent;a.dispatchEvent=function(c){return null!=c.type&&"click"==(""+c.type).toLocaleLowerCase()?(window.pbreason="blocked due to an explicit dispatchEvent event with type 'click' on an 'a' tag",parent.postMessage({type:"blockedWindow",args:JSON.stringify({0:a.href})},l),!0):b(c)},k=a}return a},document.createEvent=function(){try{return arguments[0].toLowerCase().indexOf("mouse")>=0&&(new Date).getTime()-j<=50?(window.pbreason="Blocked because 'a' element was recently created and "+arguments[0]+" event was created shortly after",arguments[0]=k.href,parent.postMessage({type:"blockedWindow",args:JSON.stringify({0:k.href})},l),null):h.apply(document,arguments)}catch(a){}},document.addEventListener("fullscreenchange",function(){b(document.fullscreen)},!1),document.addEventListener("mozfullscreenchange",function(){b(document.mozFullScreen)},!1),document.addEventListener("webkitfullscreenchange",function(){b(document.webkitIsFullScreen)},!1)} inject()</script>

	<body data-gr-c-s-loaded="true">

		<div id="page">
			<div id="topPage">
				<div id="topPageTitles">
					<nav class="navbar navbar-inverse " role="navigation">
						<div class="container-fluid">
							<div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
								<ul class="nav navbar-nav">
									<li><a href="http://sydney.edu.au/engineering/it/courses/info3220/tutorial2.html">Week 2</a></li>
									<li><a href="http://sydney.edu.au/engineering/it/courses/info3220/tutorial3.html">Week 3</a></li>
									<li><a href="http://sydney.edu.au/engineering/it/courses/info3220/tutorial4.html">Week 4</a></li>
									<li><a href="http://sydney.edu.au/engineering/it/courses/info3220/tutorial5.html">Week 5</a></li>
									<li><a href="http://sydney.edu.au/engineering/it/courses/info3220/tutorial6.html">Week 6</a></li>
									<li><a href="http://sydney.edu.au/engineering/it/courses/info3220/tutorial7.html">Week 7</a></li>
									<li><a href="http://sydney.edu.au/engineering/it/courses/info3220/tutorial8.html">Week 8</a></li>
									<li><a href="http://sydney.edu.au/engineering/it/courses/info3220/tutorial9.html">Week 9</a></li>
									<li><a href="http://sydney.edu.au/engineering/it/courses/info3220/tutorial10.html">Week 10</a></li>
									<li class="active"><a href="http://sydney.edu.au/engineering/it/courses/info3220/tutorial11.html">Week 11</a></li>
									<li><a href="http://sydney.edu.au/engineering/it/courses/info3220/tutorial12.html">Week 12</a></li>
									<li><a href="http://sydney.edu.au/engineering/it/courses/info3220/tutorial13.html">Week 13</a></li>
								</ul>
							</div>
						</div>
					</nav>
					<div id="header">
						<div class="titlePlacement">
							<div class="title"><h1>Week 11 Tutorial</h1></div>
							<div class="subText"><h2>The Visitor Design Pattern</h2></div>
						</div>
					</div>
				</div>
			</div>
			<div id="bottomPage">
				<div id="contentsPanel" style="position: relative; width: 27%;">
					<ul class="nav nav-pills nav-stacked">
						<li id="nav1" class="active">
							<a href="http://sydney.edu.au/engineering/it/courses/info3220/tutorial11.html#section1"><span style="float:right;" class="glyphicon glyphicon-chevron-right"></span>Overview</a>
						</li>
						<li id="nav2" class="">
							<a href="http://sydney.edu.au/engineering/it/courses/info3220/tutorial11.html#section2"><span style="float:right;" class="glyphicon glyphicon-chevron-right"></span>What is the Visitor Design Pattern</a>
						</li>
						<li id="nav3" class="">
							<a href="http://sydney.edu.au/engineering/it/courses/info3220/tutorial11.html#section3"><span style="float:right;" class="glyphicon glyphicon-chevron-right"></span>Revisiting the Computer Builder project</a>
						</li>
						<li id="nav4" class="">
							<a href="http://sydney.edu.au/engineering/it/courses/info3220/tutorial11.html#section4"><span style="float:right;" class="glyphicon glyphicon-chevron-right"></span>Dealing with the Dreaded Diamond</a>
						</li>
						<li id="nav5" class="">
							<a href="http://sydney.edu.au/engineering/it/courses/info3220/tutorial11.html#section5"><span style="float:right;" class="glyphicon glyphicon-chevron-right"></span>Creating Visitor Classes</a>
						</li>
					</ul>
				</div>
				<div id="pageContent"> 
					<div id="section1">
						<h1>Overview</h1>
						<p>This week your goal is to implement the Visitor Design Pattern in an existing code base which you have worked with previously. In this tutorial you will focus on design implications that arise from inheritance and, in particular, issues which arise when using multiple inheritance.</p>
					</div>
					<div id="section2">
						<h1>What is the Visitor Design Pattern</h1>

						<p>The Visitor design pattern aims to allow for an operation or operations to be performed on the elements of a composite structure. The Visitor design pattern therefore allows for additional operations to be added to the composite structure without changing the classes of the elements on which it operates.</p>

						<p>The Visitor design pattern consists of two sets of classes: the elements which accept a visitor and the visitor classes which provide additional functionality to the set of elements. The relationship between these two entities can be seen in the following diagram. Of note is that the Visitor interface is aware of the concrete representations of the elements while the Elements, both abstract and concrete, are only aware of the Visitor interface (base class).</p>

						<div>
							<img class="diagram" src="./INFO3220-12_files/VisitorDiagram.svg.png" alt="Visitor Design Pattern Diagram" width="400" style="display: block; margin: 0 auto;">
							<div style="text-align: center">Fig.1 - From <a href="http://en.wikipedia.org/wiki/Builder_pattern">Wikipedia</a> (derived from Design Patterns: Elements of Reusable Object-Orientated Software).</div>
						</div>

						<br>

						<p>The Visitor design pattern should be applied when:</p>

						<ul>

							<li>A composite class contains many classes with differing interfaces and you wish to perform operations on these objects that dependent on their implementation specific implementation (concrete classes)</li>

							<li>Many distinct and unrelated operations need to be performed on objects contained within a composite class and you want to avoid "polluting" their classes with this operations. Using a Visitor will allow these methods to be contained within a central repository which is decoupled from the composite class and the set of classes which define it. Implementing the structure in this way allows you to permit only the subset of instances that should have access to these methods to have it.</li>

						</ul>

						<h2>But isn't that the same as making the Visitor class a friend?</h2>

						<h3>The friend keyword</h3>

						<p>The <code>friend</code> keyword in C++ is one of the most powerful and therefore dangerous keywords in C++. It grants complete access to a class, it is the <a href="http://en.wikipedia.org/wiki/Key_(lock)#Master_key"> skeleton / master key</a> for programmers. That is, the friend keyword grants access to <code>public</code>, <code>protected</code> and <code>private</code> methods and member variables of a class.</p>

						<p>The friend keyword often gives rise to a number of arguments whenever developers discuss whether it should be used, and its use is often defined quite clearly in coding standards which deal with C++. If you are interested in the variation of opinions I would suggest reading this <a href="http://stackoverflow.com/questions/17434/when-should-you-use-friend-in-c">stackoverflow post</a>. Some of their examples are quite good cases where the friend keyword is quite useful, such as testing frameworks.</p>

						<p>What is clear is that the friend keyword permits complete access. This is not the case for the Visitor design pattern. The Visitor does not have any access to the internals of the class it is visiting it is just able to access the collection of objects within a composite class and perform operations on these objects. It cannot modify the internals of these objects unless that access is explicitly given.</p>

					</div>
					<div id="section3">
						<h1>Revisiting the Computer Builder project</h1>

						<p>In this week's tutorial you will be supplied with a slightly updated version of the <b>ComputerBuilder</b> project which you implemented in <a href="http://sydney.edu.au/engineering/it/courses/info3220/tutorial5.html">Week 5</a>. While you implemented the Builder design pattern in this project, what is interesting to look back at is the number of other design patterns which you have been introduced to since <a href="http://sydney.edu.au/engineering/it/courses/info3220/tutorial5.html">Week 5</a> which are also implemented in this code base.</p>

						<p>Some design patterns which have been implemented within this code base which you should now be familiar with include:</p>

						<ul>
							<li>The Adaptor Design Pattern: an example of the adaptor design pattern in this code base is the implementation of the <b>HardDriveSet</b> which you implemented yourself in <a href="http://sydney.edu.au/engineering/it/courses/info3220/tutorial5.html#section3">Week 5</a>. This class wrapper contains a dynamic array of <b>HardDrive</b> objects. By implementing a list of <b>Part</b>s, this allows us to store a list of <b>Part</b>s within the list of required <b>Part</b>s which is stored in the <b>Computer</b> class. This change can be made without any changes to the original <b>Part</b> interface.</li>
							<li>The Decorator Design Pattern: an example of the decorator design pattern in this code base is the implementation of the <b>Computer</b> class which you also implemented in <a href="http://sydney.edu.au/engineering/it/courses/info3220/tutorial5.html#section3">Week 5</a>. This class also acts as a wrapper class for a list of required and additional (optional) parts. In this case however, the additional parts list has no strict guidelines and allows for the computer classes structure to be updated dynamically.</li>
							<li>The Composite Pattern: an example of the composite pattern is the <b>HardDriveSet</b>. This set is a <b>Part</b> which is made up of a number of <b>Part</b>s. </li>
							<li>The Factory Pattern: the <b>PartAllocator</b> class is an example of a factory method where the subclassses decided which classes to instantiate.</li>
						</ul>

						<p>While this project currently contains a number of Creational (Builder and Factory) and Structural Design Patterns (Adaptor, Composite, and Decorator) it does not currently include any fully implemented Behavioural Design Patterns. In this tutorial you will be extending this project to provide a working implementation of the Visitor design pattern. While you have worked with behavioural design patterns before, such as the template method and iterators in <a href="http://sydney.edu.au/engineering/it/courses/info3220/tutorial9.html">Week 9</a>, this will be the first Behavioural Design pattern you have implemented from first principles. 

					</p></div>
					<div id="section4">
						<h1>Dealing with the Dreaded Diamond</h1>

						<p>The Visitor design pattern relies heavily on inheritance and in this case you will require multiple inheritance. Multiple inheritance is where a class may inherit from more than one class.</p>

						<p>How to implement or restrict multiple inheritance is one of the big differences between C++ and Java; C++ permits multiple inheritance while Java only allows a class to extend (inherit) from one other class, while allowing implementation of multiple interfaces. By allowing only multiple interfaces to be implemented Java avoids the ambiguity that may arise when permitting multiple inheritance.</p>

						<p>This ambiguity arises when you have two base classes which have two different implementations of the same method that is then not overridden in the derived class. It is unclear which of these two implementations the derived class should refer to when this method is called. The problem which arises from multiple inheritance is often referred to as the dreaded diamond or the <a href="http://objectmentor.com/resources/articles/javacpp.pdf">deadly diamond of death</a>.</p>

						<p>This is an issue which you will need to overcome when implementing the <b>Visitor</b> Design Pattern in the following project as the <b>Part</b>s hierarchy is defined as follows:</p>

						<div>
							<img class="diagram" src="./INFO3220-12_files/Diamond.jpg" alt="Parts Diagram" width="400" style="display: block; margin: 0 auto;">
							<div style="text-align: center">Fig.2 - An abstraction of the Dreaded Diamond that you will have to deal with in today's tutorial</div>
						</div>

						<br>

						<p>To overcome issues which arise from multiple inheritance, C++ provides the ability to implement virtual inheritance. Virtual inheritance is where a particular base class in an inheritance hierarchy is defined such that it shares its member data with all derived classes. In doing so you may call this base class directly from any of the derived classes. This may be unclear but don't worry as it will become clearer when you implement virtual inheritance yourself.</p>

					</div>						
					<div id="section5">
						<h1>Implementing the Visitor Design Pattern</h1>

						<p>The Visitor design pattern allows additional operations to be added to a set of objects which make up a composite class. In this case you will be providing the ability to count each <b>Part</b> which makes up the overall <b>Computer</b> object. This will be achieved with no changes to the Computer class with the exception of adding the ability to construct a list of Visitable parts. This one change, however, will be able to be leveraged for all future <b>Visitor</b> classes which may be added to this code base.</p>

						<h2>The Visitor and VisitablePart Interfaces</h2>

						<p>In the provided <a href="http://sydney.edu.au/engineering/it/courses/info3220/files/week11/week11.zip" download="Week11.zip">project</a> you have been provided with a Visitor interface. This class defines the interface that all <b>Visitor</b>s must conform to. What is interesting to note is that the <b>Visitor</b> interface does not permit any of the PartSets to be visited but that the <b>Part</b>s which are included within these sets are visitable. This is one implementation challenge which you will need to solve when implementing your <b>CountingVisitor</b>.</p>

						<p>Along with the <b>Visitor</b> interface and its concrete implementation <b>CountingVisitor</b>, you have also been provided with a <b>VisitablePart</b> base class. This abstract class defines the interface for a <b>VisitablePart</b> which is a part which can accept a <b>Visitor</b>.</p>

						<h2>Handling Circular Dependencies</h2>

						<p>While the program you have been provided does compile "out of the box" it will not once you have applied the <b>VisitablePart</b> interface using multiple inheritance. This is because forward declarations have been added (sometimes unnecessarily or incorrectly) to ensure the code currently compiles at this stage. Your task is to choose how to include the header files in <b>Visitor</b> and <b>VisitablePart</b> interfaces to ensure that a circular dependency does not arise.</p>

						<div class="alert alert-warning">
							<h4>Note</h4>
							A circular dependency is where a pair of header files include one another. Consider the case where part of class 1 depends on class 2 and part of class 2 depends on class 1. While this property is often useful, and sometime required when applying certain design patterns, you cannot import the required dependencies of each class by simply including one anotherâ€™s header files. One of the two files will need to forward declare the appropriate libraries.
						</div>

						<h2>Making all Concrete Part classes Visitable</h2>

						<p>Once you have dealt with the issue of circular dependencies you can now start to add the <b>VisitablePart</b> interface to each of the concrete class. One suggested approach to start this process is to define the <b>RequiredPart</b>, <b>OptionalPart</b> and <b>VisitablePart</b> classes inheritance as virtual with respect to the base class <b>Part</b>; for example:</p>

						<p>Replace:</p>

<pre>class RequiredPart : public Part
</pre>
						<p>With:</p>
<pre>class RequiredPart : public virtual Part
</pre>

						<div class="alert alert-warning">
							<h4>Note</h4>
							This update is required for all three sub base classes <b>RequiredPart</b>, <b>OptionalPart</b> and <b>VisitablePart</b>.
						</div>

						<p>Once you have defined the sub base classes inheritance as virtual you may add multiple inheritance to each of the concrete <b>Part</b> classes. This update should be in the following form such that you will:</p>

						<p>Replace:</p>

<pre>class Case : public RequiredPart
</pre>
						<p>With:</p>
<pre>class Case : public virtual RequiredPart
</pre>

						<p>The good news is that the code provided already includes the method signature required by the VisitablePart interface. The bad news is that you still need to implement them as they are currently empty stubs similar to the following stub from the <b>Case</b> class.</p>

<pre>void Case::accept(Visitor* visitor)
{
    //TODO
}
</pre>

						<p>You will add the appropriate code to each of these methods later but for now we would suggest that you try rerunning the tests...</p>

						<h2>More tests failed. What did I break?</h2>

						<p>By adding virtual inheritance you should see that you now fail 30 tests. Your accuracy just went from 14 / 45 failing to <b>30</b> / 45 failing just because you followed the instructions. This problem can be overcome, however, by making sure that the <b>Part</b> constructor is appropriately called when constructing each derived class of the <b>Part</b> interface. That is calling it directly from your concrete classes. An example of this fix is as follows:</p>

						<p>Before:</p>

<pre>Case::Case(const std::string &amp;name, CaseType caseType)
    : RequiredPart(name)
    , m_caseType(caseType)
{

}
</pre>

						<p>After</p>

<pre>Case::Case(const std::string &amp;name, CaseType caseType)
    : Part(name)
    , m_caseType(caseType)
{

}
</pre>

						<p>Each time you make this change to the concrete classes which inherit from either <b>RequiredPart</b> or <b>OptionalPart</b> you will see that the number of failing tests decreases. Once you have made this change in all of the concrete classes you will be back to only 14 failing tests and ready to implement the <code>void accept(Visitor* visitor)</code> methods.

						</p><div class="alert alert-warning">
							<h4>Note</h4>
							It might seem easy to argue that using multiple inheritance has caused unnecessary work for you (the developer) and made the code base unnecessarily complex. A counter argument to this is that multiple inheritance in this case is more representative of the objects which these classes aim to represent. That is, Parts should be either Required or Optional, and also should be Visitable or not Visitable. To define Parts in this way would not be possible without multiple inheritance without using another form of design such as <a href="http://en.wikipedia.org/wiki/Object_composition">Object Composition</a> (the <a href="http://sydney.edu.au/engineering/it/courses/info3220/tutorial8.html">adaptor design pattern</a>). 
						</div>

						<h2>Accepting Visitor</h2>

						<p>Accepting a visitor is one of the easier parts of today's tutorial. The code to accept a visitor can be seen below. This code can be replicated to all parts to which the visitor interface permits visitation.</p>

<pre>void Case::accept(Visitor* visitor)
{
    visitor-&gt;visit(this);
}
</pre>

						<div class="alert alert-success">
							<h4>Hint</h4>
							The <b>BluRayDrive</b> and <b>DVDDrive</b> classes are missing from the Visitor interface. Rather than changing the interface we will handle this classes within the <b>CountingVisitor</b> later. For now just make sure that you add <code>visitor-&gt;visit(this);</code> to their base class <b>DiscDrive</b>.
						</div>

						<h3>What about the PartSets?</h3>

						<p>For the <b>CPUSet</b>, <b>GraphicsCardSet</b>, <b>HardDriveSet</b> and <b>RamSet</b> you will need to redirect the accept request to each of the items that are stored within their sets. In the case of <b>HardDriveSet</b> don't worry about the different permutations of <b>HardDrive</b>. Let the <b>HardDrive</b> inheritance hierarchy take care of that for you.</p>

						<h2>Implementing the CountingVisitor class</h2>

						<p>Once you have the accept method implemented in each of the <b>Part</b> concrete classes you are ready to implement a <b>Visitor</b> class. The concrete <b>Visitor</b> class which you will be implementing will count the number of components stored within an instance of the <b>Computer</b> class. Before starting on this stage make sure that your Project compiles. If you have implemented the previous steps correctly the code should compile and run without crashing. You will notice, however, that 14 tests are still failing. Once you have implemented this class you should find that only 7 tests will fail.</p>

						<div class="alert alert-success">
							<h4>Hint</h4>
							If you are still finding that you are failing the tests, even after implementing the <b>CountingVisitor</b> class, make sure that you have initialised all the member variables within the <b>CountingVisitor</b> constructor.
						</div>

						<h2>Updating the Computer class</h2>

						<p> Your final task in today's tutorial is to finish implementing four new methods within the <b>Computer</b> class. The methods which you will need implement are marked with <code>//TODO</code> tags within <b>Computer.cpp</b> and are also listed below:</p>

<pre>/**
 * @brief getAllComputerParts creates a list of all Parts in the computer
 * @return a list of all Parts in the computer
 */
virtual Part** getAllComputerParts() const;

/**
 * @brief getVisitableParts creates a list of all visitable Parts in the computer
 * @return a list of all Visitable Parts in the computer
 */
virtual VisitablePart** getVisitableParts() const;

/**
 * @brief getVisitableRequiredParts creates a list of all visitable required parts in the computer
 * @return a list of all vistable required parts in the computer
 */
virtual VisitablePart** getVisitableRequiredParts() const;

/**
 * @brief getAdditionalPartsList creates a list of all visitable additional parts in the computer
 * @return a list of all visitable additional parts in the computer
 */
virtual VisitablePart** getVisitableAdditionalParts() const;
</pre>

						<div class="alert alert-success">
							<h4>Hint</h4>
							Make sure that you read the description of each method carefully; in particular consider what is the difference between retrieving and creating a list?
						</div>

						<p>Once you have implemented these methods rerun the tests one last time and you should find that you now pass all the tests and are greeted with the message which can be seen on the right.</p>

					</div>
				</div>
			</div>
		</div>

	
</body></html>